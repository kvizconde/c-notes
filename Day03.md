# C Notes - Day 03

---



[TOC]



---



#### Examples:

> Making a copy of a String

```c
/* precondition: dest must be large to store src */
void str_copy(char dest[], const char src[]) {
  size_t i;
  for (i = 0; src[i] != '\0'; i++) {
    dest[i] = src[i];
  }
  dest[i]='\0';
}

```

> eg:
>
> char a[100];
>
> str_copy(a, "hello");

Buffer overrun || overflow

> *C does not have out of bounds exception!*



---



## String Functions in the standard C Library



- strlen

- strcmp

  - int strcmp(const char s1[], const char s2[]);

    > - returns a negative integer if s1 is less than s2
    > - returns 0 if s1 & s2 are equal
    > - returns a positive integer if s1 is greater than s2

- strcpy(dest , src)

  *Note: programmer is responsible for ensuring dest is large enough to store src*

  **Bad Version:**

  > strncpy(dest, src, n)		/ *n is the # of characters to copy */
  >
  > eg:
  >
  > char dest[5];
  >
  > strncpy(dest, "hello", 5)		/*dest is not NULL terminated!! THIS IS BAD!! */

  

  **Safe way to call strncpy:**

  > eg: char dest[100];
  >
  > strncpy(dest, src, 99);
  >
  > dest[99] = '\0'

  

-----



## I/O (Input/Output)



I/O is performed via <u>**streams**</u>

3 streams are already available when the program starts

1. **stdin** (standard input) : associated with keyboard input by default

2. **stdout** (standard output) : associated with console outut by default

3. **stderr** (standard error) : associated with console output by default

   - **std** : names in C

   - **type** : FILE *

     

By using I/O redirection, we can change the associations of these 3 streams.

I/O redirection is a feature provided by the shell (not specific to C).

```
/* $ -> shell prompt | ./a -> program name | <inputfile> -> redirects stdin | outputfile -> redirects stdout | 2 >examplefile -> name of files and 2 > redirects stderr */

$ ./a <inputfile> outputfile 2 > exmplefile
```

**FILE *in;**

> Convention:
>
> Regular messages are printed to stdout;
>
> error messages are printed to stderr.



### Output



**printf / fprintf / sprintf**	 all work the same way

1. **printf** : prints to stdout

2. **fprintf** : prints to stream that we can specify (via the 1st argument)
  
   - printf(…) === fprintf(stdout, ...)
   
3. **sprintf** : prints to a string that we can specify (via the 1st argument)

   > eg:
   >
   > int n = 123;
   >
   > char s[100];
   >
   > sprintf(s, "%d", n);  */* s contains "123" */*



**String Format w/ printf:**

> eg:
>
> int a = 1, b = 0;
>
> printf("The sum of %d and %d is %d\n", a, b, a + b); /* format string */



A conversion specification can have up to 5 components

> long double x = 1.23456;

printf("% -10.3Lf", x);	/* only the seperator is mandatory */

- (**-**) : flag (left-adjusted)

- **-10** : minimum field width (at least 10 characters)

- **.3** : precision (3 decimal places)

- **L** : modifier

- **f** : specifier (floating-point number)

  > eg:
  >
  > int n = 12;
  >
  > printf("%5d", n);		/* -----12 */ where [ - ] is 5 empty spaces
  >
  > printf("%05d", n);		/* 0000012 */



### Common Specification:

- %d : [integer in base 10]
- %x, %X : [unsigned integer in base 16]
- %c : [char]
- %s : [string]
- %ld : [long in base 10]
- %u : [unsigned integer in base 10]
- %lu : [unsigned long in base 10]
- %f : [float or double]



## Input



⭐️ Always check the return value of an input function immediately after calling it!!



---



## Reading a Character



> #### Example:

```c
int c;
/* needs a char from stdin */
while((c = getchar()) != EOF) 
  /* prints character to stdout */
  putchar(c);
```

> *c is declared to be an int*
>
> return type of getchar() must be bigger than char in order to have extra value to indicate failure.



- Because of precedence

  > *c = getchar() != EOF is equivalent to  c = (getchar() != EOF)*

  

- **EOF** is the special value returned by getchar() on read error or an **end-of-file**.

  > *EOF is typically defined to be -1*

  

- What is end-of-file?

  > It is a condition that becomes true when we try to read past the last byte of the **<u>file</u>**



➡ For keyboard input, the end-of-file condition can be generated by pressing ctrl-d at 	the beginning of a line.

> Keyboard input is Line-Buffered.
>
> The C program only gets the input when the user  presses the 'ENTER' key.



### Demo:

```c
#include <stdio.h>
#include <ctype.h>

int main(void) {
  int c;
  
  while((c = getchar()) != EOF) {
    putchar(toupper(c)); /*converts touppercase*/
  }
  return 0;
}
```

> **To copy a file:**
>
> ./a.out < getchar.c > abc



```c
#include <stdio.h>
#include <ctype.h>

int main(void) {
  int c;
  unsigned long nlines = 0;
  
  while((c = getchar()) != EOF) {
    if (c == "\n") /*checks for new lines*/
      nlines++;
  }
  return 0;
}
```



/* input2 is the file */

$ tr -d '\r' < input.txt > input2.txt

